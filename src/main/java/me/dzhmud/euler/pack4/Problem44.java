package me.dzhmud.euler.pack4;

import me.dzhmud.euler.EulerSolution;
import me.dzhmud.euler.util.PositionSequence;

/**
 * Pentagon numbers
 *
 Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
 It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
 Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised;
 what is the value of D?
 *
 * @author dzhmud
 */
public class Problem44 implements EulerSolution {

	public static void main(String[] args) {
		long start = System.currentTimeMillis();
		System.out.println(new Problem44().getAnswer());
		System.out.println("Solution take " + (System.currentTimeMillis() - start) / 1000 + " sec");
	}

	@Override
	public String getAnswer() {
		long result = 0;
		//find first result(may be not the answer)
//		System.out.println("//find first result(may be not the answer)");
		final PositionSequence ps = PositionSequence.get(i -> Long.valueOf(i*(3*i-1)/2));
		for (int j = 2; result == 0; j++) {
			long pj = ps.getValue(j);
			for (int k = 1; k < j; k++) {
				long pk = ps.getValue(k);
				if (ps.contains(pj - pk) && ps.contains(pj + pk)) {
//					System.out.println(String.format("Found Pj(%s) = %s and Pk(%s) = %s",j, pj, k, pk));
					result = pj - pk;
					break;
				}
			}
		}
		/**
		 * To ensure that result found has optimal |Pk − Pj| value,
		 * I used to generate pentagonals until difference between
		 * subsequent values becomes bigger than difference in pair already found.
		 * Index of such pair is appr. 3.65M
		 * Checking till such index takes a looooong time,
		 * however, couple of pairs found have difference bigger than the first one
		 * (And the site says that first pair found is the right answer)
		 * So, commented this part out.
		 */
		/*
		//generate until index
		int index = (int)(2*result / 3 + 1);
		System.out.println("generate pentagonals until index = " + index);
		fillToIndex(index);
		//now check all pentagonals till index
		System.out.println("//now check all pentagonals till index");
		for (int j = 2; j <= index; j++) {
			long pj = getValue(j);
			for (int k = 1; k < j; k++) {
				long pk = getValue(k);
				long D = pj -pk;
				long sum = pj+pk;
				if (D % 2 != 0 || sum %2 != 0)
					continue;
				if (contains(D) && contains(sum)) {
					System.out.println(String.format("Found Pj = %s and Pk = %s", pj, pk));
					result = Math.min(D, result);
				}
			}
		}*/

		return "" + result;
	}

}
