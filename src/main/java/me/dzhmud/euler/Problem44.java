package me.dzhmud.euler;

import java.util.Arrays;

import static me.dzhmud.euler.Problem44.PentagonalSequence.getValue;
import static me.dzhmud.euler.Problem44.PentagonalSequence.isPentagonal;

/**
 * Pentagon numbers
 *
 Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
 It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
 Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised;
 what is the value of D?
 *
 * @author dzhmud
 */
public class Problem44 implements EulerSolution {

	public static void main(String[] args) {
		long start = System.currentTimeMillis();
		System.out.println(new Problem44().getAnswer());
		System.out.println("Solution take " + (System.currentTimeMillis() - start) / 1000 + " sec");
	}

	@Override
	public String getAnswer() {
		long result = 0;
		//find first result(may be not the answer)
//		System.out.println("//find first result(may be not the answer)");
		for (int j = 2; result == 0; j++) {
			long pj = getValue(j);
			for (int k = 1; k < j; k++) {
				long pk = getValue(k);
				if (isPentagonal(pj - pk) && isPentagonal(pj + pk)) {
//					System.out.println(String.format("Found Pj(%s) = %s and Pk(%s) = %s",j, pj, k, pk));
					result = pj - pk;
					break;
				}
			}
		}
		/**
		 * To ensure that result found has optimal |Pk − Pj| value,
		 * I used to generate pentagonals until difference between
		 * subsequent values becomes bigger than difference in pair already found.
		 * Index of such pair is appr. 3.65M
		 * Checking till such index takes a looooong time,
		 * however, couple of pairs found have difference bigger than the first one
		 * (And the site says that first pair found is the right answer)
		 * So, commented this part out.
		 */
		/*
		//generate until index
		int index = (int)(2*result / 3 + 1);
		System.out.println("generate pentagonals until index = " + index);
		fillToIndex(index);
		//now check all pentagonals till index
		System.out.println("//now check all pentagonals till index");
		for (int j = 2; j <= index; j++) {
			long pj = getValue(j);
			for (int k = 1; k < j; k++) {
				long pk = getValue(k);
				long D = pj -pk;
				long sum = pj+pk;
				if (D % 2 != 0 || sum %2 != 0)
					continue;
				if (isPentagonal(D) && isPentagonal(sum)) {
					System.out.println(String.format("Found Pj = %s and Pk = %s", pj, pk));
					result = Math.min(D, result);
				}
			}
		}*/

		return "" + result;
	}

	static class PentagonalSequence {
		private static long[] values = new long[]{1};

		static long getValue(int index) {
			if (values.length < index) {
				fillToIndex(index);
			}
			return values[index - 1];
		}

		static boolean isPentagonal(long value) {
			if (values[values.length-1] < value) {
				fillToValue(value);
				return values[values.length-1] == value;
			}
			return Arrays.binarySearch(values, value) >= 0;
		}

		private static long generateValue(long i) {
			return i*(3*i-1)/2;
		}

		static void fillToValue(long value) {
			if (values[values.length-1] < value) {
				//fill until approximate index of value
				int index = (int)Math.sqrt(value/3);
				fillToIndex(index);
				//fill until last value is => value
				while(getValue(values.length) <= value)
					fillToIndex(values.length+1);
			} else {
				System.out.println("No need to call #fillToValue(). Check your code!");
			}
		}

		static void fillToIndex(int index) {
			if (index > values.length) {
				final int prevLength = values.length;
				values = Arrays.copyOf(values, index);
				for (int i = prevLength+1; i <= values.length; i++) {
					long value = generateValue(i);
					values[i-1] = value;
				}
			}
		}

	}

}
